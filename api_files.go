/*
OpenBuckets API

The OpenBuckets web-based tool is a powerful utility that allows users to quickly locate open buckets in cloud storage systems through a simple query. In addition, it provides a convenient way to search for various file types across these open buckets, making it an essential tool for security professionals, researchers, and anyone interested in discovering exposed data. This Postman collection aims to showcase the capabilities of OpenBuckets by providing a set of API requests that demonstrate how to leverage its features. By following this collection, you'll learn how to utilize OpenBuckets to identify open buckets and search for specific file types within them.

API version: 1.0.0
Contact: support@openbuckets.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openbuckets

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// FilesAPIService FilesAPI service
type FilesAPIService service

type ApiSearchFilesRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	keywords *string
	order *string
	direction *string
	fieldToSearch *string
	fullPath *float32
	extensions *string
	lastModifiedFrom *string
	lastModifiedTo *string
	sizeFrom *string
	sizeTo *string
	start *float32
	limit *float32
	excludeBuckets *string
	buckets *string
	stopExtensions *string
}

// multiple keywords.\&quot;-\&quot; denotes stop keywords
func (r ApiSearchFilesRequest) Keywords(keywords string) ApiSearchFilesRequest {
	r.keywords = &keywords
	return r
}

// the sorting field for the search results (e.g., \&quot;size\&quot;, \&quot;lastModified\&quot;)
func (r ApiSearchFilesRequest) Order(order string) ApiSearchFilesRequest {
	r.order = &order
	return r
}

// the sorting direction for the search results (e.g., \&quot;desc\&quot; for descending)
func (r ApiSearchFilesRequest) Direction(direction string) ApiSearchFilesRequest {
	r.direction = &direction
	return r
}

// taken into consideration if you provide any of the allowed values, \&quot;cloudProvider\&quot;,\&quot;fileExtension\&quot;,\&quot;fileName\&quot;,\&quot;fileUrl\&quot;,\&quot;fullPath\&quot;
func (r ApiSearchFilesRequest) FieldToSearch(fieldToSearch string) ApiSearchFilesRequest {
	r.fieldToSearch = &fieldToSearch
	return r
}

// include the full path in the search results (1 for true, 0 for false)
func (r ApiSearchFilesRequest) FullPath(fullPath float32) ApiSearchFilesRequest {
	r.fullPath = &fullPath
	return r
}

// comma-separated list of file extensions to include (e.g., \&quot;pdf,env\&quot;)
func (r ApiSearchFilesRequest) Extensions(extensions string) ApiSearchFilesRequest {
	r.extensions = &extensions
	return r
}

// UNIX timestamp for the starting date of the last modification range
func (r ApiSearchFilesRequest) LastModifiedFrom(lastModifiedFrom string) ApiSearchFilesRequest {
	r.lastModifiedFrom = &lastModifiedFrom
	return r
}

// UNIX timestamp for the ending date of the last modification rang
func (r ApiSearchFilesRequest) LastModifiedTo(lastModifiedTo string) ApiSearchFilesRequest {
	r.lastModifiedTo = &lastModifiedTo
	return r
}

// minimum file size in bytes
func (r ApiSearchFilesRequest) SizeFrom(sizeFrom string) ApiSearchFilesRequest {
	r.sizeFrom = &sizeFrom
	return r
}

// maximum file size in bytes
func (r ApiSearchFilesRequest) SizeTo(sizeTo string) ApiSearchFilesRequest {
	r.sizeTo = &sizeTo
	return r
}

// starting index for pagination
func (r ApiSearchFilesRequest) Start(start float32) ApiSearchFilesRequest {
	r.start = &start
	return r
}

// number of search results to return per page, based on your role.  If you send a value more than the allowed limit, we set it to the allowed limit.
func (r ApiSearchFilesRequest) Limit(limit float32) ApiSearchFilesRequest {
	r.limit = &limit
	return r
}

// comma-separated list of bucket IDs to exclude from the search
func (r ApiSearchFilesRequest) ExcludeBuckets(excludeBuckets string) ApiSearchFilesRequest {
	r.excludeBuckets = &excludeBuckets
	return r
}

// filter search results to specific bucket IDs
func (r ApiSearchFilesRequest) Buckets(buckets string) ApiSearchFilesRequest {
	r.buckets = &buckets
	return r
}

// comma-separated list of file extensions to exclude with or without \&quot;.\&quot; (e.g., sql, .sql)
func (r ApiSearchFilesRequest) StopExtensions(stopExtensions string) ApiSearchFilesRequest {
	r.stopExtensions = &stopExtensions
	return r
}

func (r ApiSearchFilesRequest) Execute() (*FileSearchResults, *http.Response, error) {
	return r.ApiService.SearchFilesExecute(r)
}

/*
SearchFiles Search Files

This request allows you to perform a highly specific search for files within the OpenBuckets database using advanced filters. You can narrow down the search based on various criteria such as keywords, order, size, date range, file extensions, and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchFilesRequest
*/
func (a *FilesAPIService) SearchFiles(ctx context.Context) ApiSearchFilesRequest {
	return ApiSearchFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FileSearchResults
func (a *FilesAPIService) SearchFilesExecute(r ApiSearchFilesRequest) (*FileSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.SearchFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keywords", r.keywords, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.fieldToSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field-to-search", r.fieldToSearch, "")
	}
	if r.fullPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full-path", r.fullPath, "")
	}
	if r.extensions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extensions", r.extensions, "")
	}
	if r.lastModifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last-modified-from", r.lastModifiedFrom, "")
	}
	if r.lastModifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last-modified-to", r.lastModifiedTo, "")
	}
	if r.sizeFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size-from", r.sizeFrom, "")
	}
	if r.sizeTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size-to", r.sizeTo, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.excludeBuckets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude-buckets", r.excludeBuckets, "")
	}
	if r.buckets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buckets", r.buckets, "")
	}
	if r.stopExtensions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stop-extensions", r.stopExtensions, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
